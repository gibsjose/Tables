#!/usr/bin/env python3.4

from enum import Enum
import sys, os, traceback, optparse
import re
import operator
import time
import csv

class Algorithm(Enum):
    first_fit = 0
    best_fit = 1
    worst_fit = 2
    random = 3

class SeatPacker:
    def __init__(self, guests = [], tables = [], algorithm = 'first-fit'):
        self.guests = guests
        self.tables = tables
        self.start_time = time.time()
        self.end_time = time.time()

        if algorithm == 'first-fit':
            self.algorithm = Algorithm.first_fit
        elif algorithm == 'best-fit':
            self.algorithm = Algorithm.best_fit
        elif algorithm == 'worst-fit':
            self.algorithm = Algorithm.worst_fit
        elif algorithm == 'random':
            self.algorithm = Algorithm.random
        else:
            raise Exception('Unknown algorithm: ' + algorithm)

        self.algorithm_str = algorithm

    def Run(self):
        self.start_time = time.time()
        #...
        self.end_time = time.time()

    def Print(self):
        print(self.algorithm_str + ' runtime: ' + str((self.end_time - self.start_time) * 1000) + ' ms')

class Guest:
    def __init__(self, name, size, children):
        self.name = name
        self.size = size
        self.children = children

    def Print(self):
        print('\t{:<20}{:>3}\t'.format(self.name, str(self.size)) + '\tChildren: ' + str(self.children))

class Table:
    def __init__(self, name, size):
        self.name = name
        self.size = size

    def Print(self):
        print('\t{:<20}{:>3} seats'.format(self.name, str(self.size)))

class Guests:
    def __init__(self, guest_file):
        self.file = guest_file
        self.list = []
        self.count = 0
        self.people = 0

        temp_list = []

        with open(self.file, 'r') as f:
            reader = csv.reader(f)
            temp_list = [tuple(line) for line in reader]

            for item in temp_list:
                if item[2].lower().strip() == 'true':
                    guest = Guest(item[0], int(item[1]), True)
                else:
                    guest = Guest(item[0], int(item[1]), False)

                self.list.append(guest)

            self.count = len(self.list)

            for guest in self.list:
                self.people += int(guest.size)

    def Print(self):
        print('There are ' + str(self.count) + ' parties and ' + str(self.people) + ' total guests:')

        for guest in self.list:
            guest.Print()

        print('')

class Tables:
    def __init__(self, table_count, table_file):
        self.table_count = table_count
        self.file = table_file
        self.list = []
        self.count = 0
        self.seats = 0

    def ParseTableCount(self):
        print('ParseTableCount')

    def ParseTableFile(self):
        temp_list = []

        with open(self.file, 'r') as f:
            for line in f:
                if line.startswith('$'):
                    continue
                elif line.isspace():
                    continue
                else:
                    line = line.translate({ord(i):None for i in ' ()\n'})
                    temp_list.append(tuple(line.split(',')))

            offset = 1

            for item in temp_list:
                for i in range(1, int(item[0]) + 1):
                    table = Table('Table ' + str(offset), int(item[1]))
                    self.list.append(table)
                    offset = offset + 1


            self.count = len(self.list)

            for table in self.list:
                self.seats += table.size

    def ParseTables(self):
        if self.table_count:
            self.ParseTableCount()
        else:
            self.ParseTableFile()

    def Print(self):
        print('There are ' + str(self.count) + ' tables and ' + str(self.seats) + ' total seats:')

        for table in self.list:
            table.Print()

        print('')

def main ():
    global options, args

    if options.verbose:
        print('Options:')
        if options.guest_file:
            print('\tGuest File: ' + options.guest_file)
        if options.tables:
            print('\tTables: ' + options.tables)
        if options.table_file:
            print('\tTable File: ' + options.table_file)
        if options.output_file:
            print('\tOutput File: ' + options.output_file)
        if options.interactive:
            print('\tInteractive Mode')
        if options.diagram:
            print('\tDiagram Mode')
        if options.verbose:
            print('\tVerbose Mode')
        if options.quiet:
            print('\tQuiet Mode')
        if options.algorithm:
            print('\tAlgorithm: ' + options.algorithm)

    if options.tables:
        tables = Tables(options.tables, None)
    elif options.table_file:
        tables = Tables(None, options.table_file)
    else:
        raise Exception('Must supply table information through either -t or -T')
        sys.exit(1)

    print('')

    #Create the guest list
    guests = Guests(options.guest_file)
    guests.Print()

    #Parse the table file/count
    tables.ParseTables()
    tables.Print()

    #Use the algorithm supplied or default to 'first-fit'
    if options.algorithm:
        algorithm = options.algorithm
    else:
        algorithm = 'first-fit'

    #Perform the bin packing
    packer = SeatPacker(guests, tables, algorithm)
    packer.Run()
    packer.Print()

    #Write the output file
    if options.output_file:
        output_file = options.output_file
    else:
        #@TODO Figure out a way to make this better in terms of UI... Asking for input is probably decent, but it screws up the algorithm timing...
        #Maybe it would be better to time the placement algorithm itself in addition to the total runtime of the script...
        #output_file = input('Output Filename: ')
        output_file = 'map.tables'

    #packer.Write(options.output_file)

if __name__ == '__main__':
    try:
        start_time = time.time()
        parser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter(), usage=globals()['__doc__'], version='$Id$')

        parser.add_option('-g', '--guest', action='store', type='string', dest='guest_file', help='guest file')

        parser.add_option('-t', '--table', action='store', type='string', dest='tables', help='\'-t (t, p)\' assume `t` tables with `p` people each - cannot be used with `-T`')

        parser.add_option('-T', '--Table', action='store', type='string', dest='table_file', help='table file - cannot be used with `-t`')

        parser.add_option('-o', '--output', action='store', type='string', dest='output_file', help='output file')

        parser.add_option('-i', '--interactive', action='store_true', default=False, help='interactive mode')

        parser.add_option('-d', '--diagram', action='store_true', default=False, help='diagram mode')

        parser.add_option('-v', '--verbose', action='store_true', default=False, help='verbose mode')

        parser.add_option('-q', '--quiet', action='store_true', default=False, help='quiet mode')

        parser.add_option('-a', '--algorithm', action='store', type='string', dest='algorithm', help='algorithm selection: first-fit, best-fit, worst-fit, random')

        (options, args) = parser.parse_args()

        if not options.guest_file:
            parser.error('missing argument: -g GUEST_FILE')

        main()
        if options.verbose: print('\n' + time.asctime())
        if options.verbose: print('Total Runtime: ', end='')
        if options.verbose: print(str((time.time() - start_time) * 1000) + ' ms')
        sys.exit(0)
    except KeyboardInterrupt as e: # Ctrl-C
        raise e
    except SystemExit as e: # sys.exit()
        raise e
    except Exception as e:
        print('Error: Unexpected Exception')
        print(str(e))
        traceback.print_exc()
        os._exit(1)
