#!/usr/bin/env python3.4

from enum import Enum
import sys, os, traceback, optparse
import re
import operator
import time
import csv

class Algorithm(Enum):
    first_fit = 0
    best_fit = 1
    worst_fit = 2
    random = 3

class SeatPacker:
    def __init__(self, guests = [], tables = [], algorithm = 'first-fit'):
        self.guests = guests
        self.tables = tables

        if algorithm == 'first-fit':
            self.algorithm = Algorithm.first_fit
        elif algorithm == 'best-fit':
            self.algorithm = Algorithm.best_fit
        elif algorithm == 'worst-fit':
            self.algorithm = Algorithm.worst_fit
        elif algorithm == 'random':
            self.algorithm = Algorithm.random
        else:
            print('Error: Unknown algorithm: ' + algorithm)
            sys.exit(1)

        self.algorithm_str = algorithm

    def Print(self):
        print('Algorithm: ' + self.algorithm_str)

class Guest:
    def __init__(self, name, size, children):
        self.name = name
        self.size = size
        self.children = children

    def Print(self):
        print(self.name + ': ' + str(self.size) + ', Children: ' + str(self.children))

class Table:
    def __init__(self, name, size):
        self.name = name
        self.size = size

    def Print(self):
        print(self.name + ' (' + str(self.size) + ')')

class Guests:
    def __init__(self, guest_file):
        self.file = guest_file
        self.list = []
        self.count = 0
        self.people = 0

        with open(self.file, 'r') as f:
            reader = csv.reader(f)
            self.list = [tuple(line) for line in reader]
            self.count = len(self.list)

            for guest in self.list:
                self.people += int(guest[1])

    def Print(self):
        print('There are ' + str(self.count) + ' parties and ' + str(self.people) + ' total guests:')
        print(self.list, end='\n\n')

class Tables:
    def __init__(self, table_count, table_file):
        self.table_count = table_count
        self.file = table_file
        self.list = []
        self.count = 0
        self.seats = 0

    def ParseTableCount(self):
        print('ParseTableCount')

    def ParseTableFile(self):
        temp_list = []

        with open(self.file, 'r') as f:
            for line in f:
                if line.startswith('$'):
                    continue
                elif line.isspace():
                    continue
                else:
                    line = line.translate({ord(i):None for i in ' ()\n'})
                    temp_list.append(tuple(line.split(',')))

            offset = 1

            for table in temp_list:
                for i in range(1, int(table[0]) + 1):
                    self.list.append(('Table ' + str(offset), int(table[1])))
                    offset = offset + 1

        self.count = len(self.list)

        for table in self.list:
            self.seats += int(table[1])

    def ParseTables(self):
        if self.table_count:
            self.ParseTableCount()
        else:
            self.ParseTableFile()

    def Print(self):
        print('There are ' + str(self.count) + ' tables and ' + str(self.seats) + ' total seats:')
        print(self.list, end='\n\n')

def main ():
    global options, args

    if options.verbose:
        print('Options:')
        if options.guest_file:
            print('Guest File: ' + options.guest_file)
        elif options.tables:
            print('Tables: ' + options.tables)
        elif options.table_file:
            print('Table File: ' + options.table_file)
        elif options.output_file:
            print('Output File: ' + options.output_file)
        elif options.interactive:
            print('Interactive Mode')
        elif options.diagram:
            print('Diagram Mode')
        elif options.verbose:
            print('Verbose Mode')
        elif options.quiet:
            print('Quiet Mode')
        elif options.algorithm:
            print('Algorithm: ' + options.algorithm)

    if options.tables:
        tables = Tables(options.tables, None)
    elif options.table_file:
        tables = Tables(None, options.table_file)
    else:
        raise Exception('Must supply table information through either -t or -T')
        sys.exit(1)

    #Create the guest list
    guests = Guests(options.guest_file)
    guests.Print()

    #Parse the table file/count
    tables.ParseTables()
    tables.Print()

    #Use the algorithm supplied or default to 'first-fit'
    if not options.algorithm:
        options.algorithm = 'first-fit'

    #Perform the bin packing
    packer = SeatPacker(guests, tables, options.algorithm)
    packer.Print()

    #Write the output file
    #packer.Write(options.output_file)

if __name__ == '__main__':
    try:
        start_time = time.time()
        parser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter(), usage=globals()['__doc__'], version='$Id$')

        parser.add_option('-g', '--guest', action='store', type='string', dest='guest_file', help='guest file')

        parser.add_option('-t', '--table', action='store', type='string', dest='tables', help='\'-t (t, p)\' assume `t` tables with `p` people each - cannot be used with `-T`')

        parser.add_option('-T', '--Table', action='store', type='string', dest='table_file', help='table file - cannot be used with `-t`')

        parser.add_option('-o', '--output', action='store', type='string', dest='output_file', help='output file')

        parser.add_option('-i', '--interactive', action='store_true', default=False, help='interactive mode')

        parser.add_option('-d', '--diagram', action='store_true', default=False, help='diagram mode')

        parser.add_option('-v', '--verbose', action='store_true', default=False, help='verbose mode')

        parser.add_option('-q', '--quiet', action='store_true', default=False, help='quiet mode')

        parser.add_option('-a', '--algorithm', action='store', type='string', dest='algorithm', help='algorithm selection: first-fit, best-fit, worst-fit, random')

        (options, args) = parser.parse_args()

        if not options.guest_file:
            parser.error('missing argument: -g GUEST_FILE')

        main()
        if options.verbose: print('\n' + time.asctime())
        if options.verbose: print('Total Runtime: ', end='')
        if options.verbose: print(str((time.time() - start_time) * 1000) + ' ms')
        sys.exit(0)
    except KeyboardInterrupt as e: # Ctrl-C
        raise e
    except SystemExit as e: # sys.exit()
        raise e
    except Exception as e:
        print('Error: Unexpected Exception')
        print(str(e))
        traceback.print_exc()
        os._exit(1)
